# KairosAgent - 自律AIエージェントシステム ロードマップ

## Context

個人開発者が長期的な目標を設定し、AIエージェントが自律的に調査・計画・実装・改善を繰り返すCLIベースのシステムを構築する。PoorDevSkills（開発パイプラインフレームワーク）と同じ思想で、各「部署」をパイプラインステージとして実装する。

先行事例（AutoGPT, HustleGPT, SICA, OpenClaw, Loki Mode等）の調査から、完全自律エージェントは2026年現在の技術水準ではリスクが高いことが判明。**半自律スタート + 段階的自律化（信頼レベルシステム）** を採用する。

### 初期目標

- **短期**: システムの安定稼働（最優先）
- **中期**: 月$200の収益（Claudeサブスク費用のペイ）
- **長期**: 段階的自律化による収益拡大

### 前回（KairosAgent）の反省

前身のKairosAgentは以下の理由で失敗し、リセットした：

1. **全部同時に作った** — 8フェーズ×三審制×インターン委譲×ハイブリッドAI×安全機構を一度に構築。相互依存が増え、どれか1つが壊れると全体が動かない
2. **前提の誤りに気づくのが遅い** — 設計を先に作り込みすぎて、前提が崩れた（OpenCode≒GLM問題等）ときのやり直しコストが大きかった
3. **動くものがない状態でメタ仕組みを作り込んだ** — 稼ぐタスクを1つもこなしてない状態でインターン委譲や三審制を実装した

**今回の方針: 最小ループを先に回す。動くものを作ってから磨く。**

---

## アーキテクチャ

### 全体構造

```
オーナー（人間）
│  goals.md / directive（目標・方針指示）
│
KairosAgent（パイプラインオーケストレーション層）
│
├── CLI (autoclaude)    — 人間介入インターフェース
├── workspace/          — 部署間通信（md/json）
│
└── 部署パイプライン（DevSkillsと同じ思想）
    各部署 = パイプラインステージ
    ステージ間 = KPIファイル + 要件ファイルで通信
```

### 4層フロー

```
オーナー（人間）: 「月$200稼げ。損失上限$50」
    │ goals.md
    ▼
経営部: 戦略策定・フェーズ分割・リソース配分
    │ indicators.json + directives.md（指標 + 方針）
    ▼
企画部: 指標→具体的な数値目標と施策に落とす
    │ targets.json + assignments.json（数値目標 + 作業指示）
    ▼
実行部: 実装・調査・測定・改善
    │ metrics.json + execution-report.md（実測値 + 報告）
    ▼
  （ファイルに書かれた時点で全部署から参照可能 → 次サイクルで経営部が読む）
```

### 部署 = パイプラインステージ

各部署はPoorDevSkillsのパイプラインステージと同じインターフェースを持つ：

```
入力:
  - 前ステージの出力ファイル（KPI + 要件）
  - workspace内の任意ファイル（他部署の状態も参照可能）

処理:
  - 判断（進める / 止める / 差し戻す）

出力:
  - KPIファイル（自部署の指標・数値・実測値）
  - 要件ファイル（次ステージへの指示）
  - ステータス: continue / hold / reject
```

- **ステータスがcontinue** → 次のステージをdispatch
- **ステータスがhold/reject** → パイプライン停止、上流にエスカレーション

### KPI三層カスケード

KPIは各部署で性質が異なり、上流から下流にカスケードする：

| 部署 | KPIの性質 | ファイル | 例 |
|------|-----------|----------|-----|
| 経営部 | 指標（方向性） | `indicators.json` | "品質重視" "コスト削減" "機能拡充" |
| 企画部 | 数値目標 | `targets.json` | "テストカバレッジ80%" "月間コスト$80以内" |
| 実装部 | 実測値 | `metrics.json` | "カバレッジ65%、+3%/週" "応答350ms" |

- 経営部は抽象的な指標を出す
- 企画部がそれを具体的な数値と施策に変換する
- 実装部がその数値に対する進捗を測定し改善する
- 実測値が経営部に戻ってループする

### エスカレーションチェーン

任意の部署がパイプラインを「止める」ことができる。止めた場合、上流の部署にエスカレーションされる：

```
実装部「技術的に無理」→ 企画部にエスカレーション
  → 企画部「要件を変えれば可能」→ 解決、パイプライン再開
  → 企画部「方針の問題」→ 経営部にエスカレーション
    → 経営部「方針変更で対応」→ 解決
    → 経営部「判断できない」→ オーナー（人間）にエスカレーション
```

- エスカレーション時はhold理由がファイルに記録される
- 上流部署が解決できなければさらに上流へ
- 最終的に人間に到達 = 承認キュー（approval-queue）に入る
- ループ検知: 同一案件のエスカレーション回数に上限を設ける

**承認キューはエスカレーションの終着点**として統合される。別の仕組みではなく、パイプラインの「止め」が上流に伝播した結果。

### 信頼レベルとエスカレーションの連動

| Level | エスカレーション時の動作 |
|-------|------------------------|
| 0（全承認） | 即座に人間にエスカレーション |
| 1（低リスク自律） | 上流部署が自律的に解決を試みる。失敗時は人間へ |
| 2（日常自律） | 定型的な問題は自律解決。新規・高額は人間へ |
| 3（高自律） | 支出上限内なら自律解決。上限超えのみ人間へ |

### 部署間通信

- **md/jsonファイルのみ**（エージェント出力の直接パイプは禁止）
- 各ファイルに所有権を設定（書き込み1部署、読み取り全部署）
- スキーマバリデーション必須
- 「事実」と「推測」を明示的にタグ付け
- **情報は全方向に参照可能** — 制御フローは一方向だが、ファイルに書かれた時点でどの部署からも読める

### Claude呼び出し

DevSkillsの `dispatch-step.sh` パターンを全部署で統一：
```bash
cd "$PROJECT_DIR" && cat "$PROMPT_FILE" | env -u CLAUDECODE claude -p --model "$MODEL" --no-session-persistence --output-format text
```

---

## 信頼レベルシステム

半自律スタート→段階的自律化の核心。パイプライン基盤が安定してから導入する（Phase 4）。

### レベル定義

| Level | 名称 | 動作 |
|-------|------|------|
| 0 | 全承認 | 全ステップで人間が承認してから実行 |
| 1 | 低リスク自律 | 読み取り専用アクション（調査、分析）は自動。書き込みは承認 |
| 2 | 日常自律 | 定型タスクは自動。新規/高額/外部連携は承認 |
| 3 | 高自律 | 支出上限内なら自動。上限超えのみ承認 |

### 昇格・降格ルール

- **昇格**: 連続N回成功（人間がレビューで問題なしと判定）→ Level +1
- **降格**: 失敗または問題発見 → 即座にLevel 0に戻す
- **定期監査**: N回サイクルごとに人間が全状態をレビュー

---

## CLIインターフェース

```bash
# パイプライン実行（手動）
autoclaude run                    # 全部署パイプラインを1サイクル実行
autoclaude run --department exec  # 特定部署のみ実行
autoclaude run --dry-run          # 実行せずに何が起きるか表示

# 目標・方針設定
autoclaude directive "月$200を稼ぐ方法を調査しろ"

# 現在の状態を確認
autoclaude status

# KPIダッシュボード（三層表示）
autoclaude kpi                    # 全層サマリー
autoclaude kpi --indicators       # 経営指標のみ
autoclaude kpi --targets          # 数値目標のみ
autoclaude kpi --metrics          # 実測値のみ

# エスカレーション・承認キュー
autoclaude queue                  # エスカレーション一覧
autoclaude approve 3              # ID=3を承認
autoclaude reject 3 "理由"        # ID=3を却下

# 信頼レベル管理（Phase 4以降）
autoclaude trust                  # 現在のレベル一覧
autoclaude trust promote planning # 企画部をLevel+1
autoclaude trust demote execution # 実行部をLevel 0に

# ハートビート制御（Phase 3以降）
autoclaude heartbeat              # 手動で1回実行
autoclaude heartbeat --dry-run    # 実行せずに表示

# 緊急停止
autoclaude stop

# ログ確認
autoclaude logs
autoclaude logs --tail 10
```

---

## ワークスペース構造

```
workspace/
├── config.json                     # システム設定（モデル設定、支出上限等）
├── goals.md                        # オーナーの目標（人間が書く）
├── spending-ledger.json            # 支出台帳（API呼び出しコスト等）
│
├── departments/
│   ├── management/
│   │   ├── indicators.json         # 経営指標（KPI上位層）
│   │   ├── directives.md           # 経営方針
│   │   ├── summary.md              # 経営部の状態要約
│   │   └── analysis/               # 分析結果の履歴
│   ├── planning/
│   │   ├── targets.json            # 数値目標（KPI中位層）
│   │   ├── assignments.json        # 実行部への作業指示
│   │   ├── research-report.md      # 調査結果
│   │   └── summary.md
│   └── execution/
│       ├── metrics.json            # 実測値（KPI下位層）
│       ├── execution-report.md     # 実行報告
│       └── summary.md
│
├── escalation/
│   ├── queue.json                  # エスカレーションキュー（人間承認待ち含む）
│   └── history/                    # 過去のエスカレーション記録
│
├── pipeline/
│   ├── stages.json                 # 部署（ステージ）定義
│   └── state.json                  # 現在のパイプライン状態
│
├── trust/                          # Phase 4以降
│   └── levels.json                 # 信頼レベル管理
│
├── logs/
│   ├── YYYY-MM-DD-HH-cycle.json   # サイクルログ
│   └── archive/                    # 月次アーカイブ
│
└── history/                        # 過去のdirectives/assignmentsアーカイブ
    └── YYYY-MM/
```

---

## リスク対策マトリックス

| リスク | 対策 | 実装Phase |
|--------|------|-----------|
| **システム構築の目的化** | 最小ループを先に回す。完璧な基盤より1サイクル通しを優先 | 全Phase |
| 判断ドリフト | goals.mdとの乖離度スコアリング + 定期監査 | Phase 2 |
| ハルシネ蓄積 | スキーマバリデーション + 事実/推測タグ | Phase 1 |
| コスト爆発 | spending-ledger + モデル使い分け | Phase 1 |
| エスカレーションループ | 同一案件のエスカレーション回数上限 + ループ検知 | Phase 1 |
| 経営部AIの判断が浅い | Level 0では人間と協働。実績データ蓄積後に自律化 | Phase 2→4 |
| 中間KPIの測定困難 | 測定可能な指標のみ採用。「測れないKPIは置かない」原則 | Phase 2 |
| 自己改善の暴走 | 提案のみ出力（適用は人間承認）+ 安全機構は改善対象外 | Phase 6 |
| 長期稼働劣化 | ログローテーション + 状態スナップショット + history移動 | Phase 3 |
| ファイル通信の競合 | ファイル所有権制度 + 読み書き分離 | Phase 1 |

---

## ロードマップ

### Phase 0: DevSkills成熟（並行・別リポジトリ）
> KairosAgentと並行してDevSkillsで進める。Phase 2以降の連携に必要。

- [ ] カスタムフロー登録機能（`get_pipeline_steps()`の外部化）
- [ ] 外部コマンドディレクトリ対応（commands/以外からの読み込み）
- [ ] GLM5対応の安定化（`command_variant: "simple"` + `review_mode: "bash"`）
- [ ] dispatch-step.shの汎用化（DevSkills固有のパスを引数化）

### Phase 1: パイプライン基盤 + 最小部署
> **動くものを最初に作る。** DevSkillsなしで独立して構築可能。

- [ ] workspace/ディレクトリ構造の初期化スクリプト
- [ ] config.json（モデル設定、支出上限）
- [ ] 部署（ステージ）の共通インターフェース定義（`stages.json`）
- [ ] KPI三層ファイル構造（indicators.json / targets.json / metrics.json）
- [ ] 部署間のKPI+要件ファイル受け渡しロジック
- [ ] エスカレーション機構（止める→上流に戻す→最終的に人間へ）
- [ ] ループ検知（同一案件のエスカレーション回数上限）
- [ ] 最小部署1つ（実行部相当）を実装し、手動CLIで1サイクル回す
- [ ] CLIツール `autoclaude`（run, status, directive, queue, approve, reject）
- [ ] spending-ledger.json + 支出追跡
- [ ] ログ基盤
- [ ] ファイル所有権制度の定義
- [ ] スキーマバリデーション

### Phase 2: 部署の段階的追加
> 1部署ずつ追加。追加するたびに実際に回して検証。

- [ ] 経営部の追加（Level 0 = 人間と協働で方針策定）
  - [ ] 経営分析プロンプト（goals.md参照 → 指標提案 → indicators.json）
  - [ ] 人間承認 → directives.md確定フロー
  - [ ] KPI収集・集計スクリプト（bash、事務処理相当）
  - [ ] ドリフト検知（goals.mdとの乖離度スコアリング）
- [ ] 企画部の追加
  - [ ] 方針→仕様変換プロンプト（indicators.json + directives.md → targets.json + assignments.json）
  - [ ] 調査サブフロー（WebSearch等 → research-report.md）
- [ ] 実行部の拡充
  - [ ] assignments.json → DevSkills pipeline-runner.sh連携
  - [ ] 実測値 → metrics.json反映
  - [ ] execution-report.md生成
- [ ] 全部署パイプライン通しテスト（経営→企画→実行の1サイクル）
- [ ] ダッシュボード（`autoclaude kpi` 三層表示）

### Phase 3: ハートビート（自動化）
> パイプラインが安定してから自動実行を導入。

- [ ] heartbeat.sh（cron対応、排他制御）
- [ ] 差分検知による早期終了（コスト$0サイクル実現）
- [ ] `autoclaude heartbeat` コマンド追加
- [ ] ログローテーション + history移動
- [ ] 支出上限超過時の自動停止

### Phase 4: 信頼レベル昇格
> 段階的自律化。手動運用の実績データに基づいて導入。

- [ ] trust/levels.json + 信頼レベル管理ロジック
- [ ] 各サイクルの成功率トラッキング
- [ ] 昇格条件の自動判定（連続N回成功 → Level +1）
- [ ] 降格機構（失敗 → 即座にLevel 0）
- [ ] エスカレーション解決と信頼レベルの連動
- [ ] 監査ログ
- [ ] `autoclaude trust` コマンド追加

### Phase 5: 部署分離・拡張
> 運用実績に基づいて必要な部署を分離・追加。

- [ ] 調査部を企画部から分離（独立ステージ化）
- [ ] 外交部を実行部から分離（メール、サービス登録、外部やり取り）
- [ ] 事務部の明示化（メトリクス自動化、レポート生成）
- [ ] 新ステージ追加は既存パイプラインへの1ステージ追加で完了する設計

### Phase 6: 自己改善（慎重に）
> 十分な運用実績が蓄積されてから着手。

- [ ] プロンプト改善の提案機能（適用は人間承認）
- [ ] フロー最適化の提案機能
- [ ] 安全機構（trust, escalation, spending-ledger）は改善対象から除外
- [ ] 改善前後のベンチマーク比較必須
- [ ] ロールバック機構

---

## 技術スタック

| コンポーネント | 技術 |
|-------------|------|
| 言語 | TypeScript（CLIツール）+ bash（heartbeat, 事務処理） |
| フローエンジン | 独自パイプライン（DevSkillsと同じ思想、Phase 2以降でDevSkills連携） |
| AI呼び出し | Claude Code CLI（非対話モード）via dispatch-step.sh |
| モデル | 日常判断: Sonnet/Haiku、重要判断: Opus、安価作業: GLM5 |
| 状態管理 | JSON/Markdownファイル（Git管理可能） |
| スケジューラ | cron or systemdタイマー（Phase 3以降） |
| バージョン管理 | Git（workspace/をコミット対象に） |

---

## 参考プロジェクト

| プロジェクト | 参考ポイント |
|-------------|-------------|
| OpenClaw | Heartbeat、Markdown/YAMLメモリ、AGENTS.md |
| Loki Mode | RARVサイクル、Completion Council、フェーズ管理 |
| SICA | 自己改善ループ、ベンチマーク駆動 |
| BabyAGI | タスク駆動型の最小限設計 |
| Auto-Claude | Claude Codeベースのパイプライン |
| Darwin Godel Machine | 進化的アプローチ、複数バリアント |

---

## コスト見積り

### 最適化前（最悪ケース）
- 30分間隔 × 3部署 × Claude Opus: 約$25/日、月$756

### 最適化後（目標）
- 差分検知で50%のサイクルを早期終了: コスト半減
- Sonnet/Haiku使い分けで70%コスト削減
- バッチAPIで50%割引
- **目標: 月$50-100程度**
- **収益目標: 月$200（Claudeサブスク費用のペイ）**

---

## 検証方法

### Phase 1 検証
1. 最小部署で `autoclaude run` が1サイクル完走すること
2. エスカレーション発生時に上流→人間への伝播を確認
3. KPIファイル（indicators/targets/metrics）の生成・読み取り確認
4. CLIの基本コマンド動作確認

### Phase 2 検証
1. テスト用の簡単な目標（例：「README.mdを書く」）で全部署サイクルを1周
2. Level 0（人間協働）での全承認フロー動作確認
3. KPI三層ダッシュボード表示
4. 止める→エスカレーション→解決の一連のフロー

### Phase 3 検証
1. heartbeat自動実行で差分検知が動作すること
2. ロック機構（2つ同時起動で片方が即終了）
3. 支出上限超過時の停止動作

### 長期検証
1. 24時間連続稼働でのログ肥大化チェック
2. 10サイクル後のドリフト検知精度
3. 信頼レベル昇格/降格の動作確認

---

## 実装時の注意事項

- **最小ループを先に回す** — 完璧な基盤より「1サイクル通し」を最優先
- **部署は1つずつ追加** — 全部署同時実装は前回の失敗パターン
- **ハートビートは後から** — パイプラインが動いてから自動化
- **測れないKPIは置かない** — 測定不可能な指標はドリフトの原因
- Phase 0（DevSkills拡張）は別リポジトリ（/home/bacon/DevSkills/）で並行実装
- 各Phase完了後に動作確認してから次へ
- 自己改善（Phase 6）は十分な運用実績が蓄積されてから着手
